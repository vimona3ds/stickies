"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkstickies"] = self["webpackChunkstickies"] || []).push([["main"],{

/***/ "./src/index.scss":
/*!************************!*\
  !*** ./src/index.scss ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n\n\n//# sourceURL=webpack://stickies/./src/index.scss?");

/***/ }),

/***/ "./src/audio.ts":
/*!**********************!*\
  !*** ./src/audio.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.sounds = exports.Sound = void 0;\nexports.loadAllSounds = loadAllSounds;\n// from https://stackoverflow.com/questions/25654558/html5-js-play-same-sound-multiple-times-at-the-same-time\nwindow.AudioContext = window.AudioContext || window.webkitAudioContext;\nconst context = new AudioContext();\nclass Sound {\n    url;\n    buffer;\n    sources;\n    loop;\n    constructor(url, loop = false) {\n        this.url = url;\n        this.buffer = null;\n        this.sources = [];\n        this.loop = loop;\n    }\n    load() {\n        if (this.buffer)\n            return Promise.resolve(this.buffer);\n        return new Promise((resolve, reject) => {\n            const request = new XMLHttpRequest();\n            request.open('GET', this.url, true);\n            request.responseType = 'arraybuffer';\n            // Decode asynchronously:\n            request.onload = () => {\n                context.decodeAudioData(request.response, (buffer) => {\n                    if (!buffer) {\n                        console.log(`Sound decoding error: ${this.url}`);\n                        reject(new Error(`Sound decoding error: ${this.url}`));\n                        return;\n                    }\n                    this.buffer = buffer;\n                    resolve(buffer);\n                });\n            };\n            request.onerror = (err) => {\n                console.log('Sound XMLHttpRequest error:', err);\n                reject(err);\n            };\n            request.send();\n        });\n    }\n    play(volume = 1, time = 0) {\n        if (!this.buffer) {\n            return;\n        }\n        // Create a new sound source and assign it the loaded sound's buffer:\n        const source = context.createBufferSource();\n        source.buffer = this.buffer;\n        source.loop = this.loop;\n        // Keep track of all sources created, and stop tracking them once they finish playing:\n        const insertedAt = this.sources.push(source) - 1;\n        source.onended = () => {\n            // source.stop(0);\n            // this.sources.splice(insertedAt, 1);\n        };\n        // Create a gain node with the desired volume:\n        const gainNode = context.createGain();\n        gainNode.gain.value = volume;\n        // Connect nodes:\n        source.connect(gainNode).connect(context.destination);\n        // Start playing at the desired time:\n        source.start(time);\n    }\n    stop() {\n        // Stop any sources still playing:\n        this.sources.forEach((source) => {\n            source.stop(0);\n        });\n        this.sources = [];\n    }\n}\nexports.Sound = Sound;\nexports.sounds = {\n    countdown: new Sound(\"./sounds/countdown.mp3\"),\n    start: new Sound(\"./sounds/start.mp3\"),\n    click: new Sound(\"./sounds/click.mp3\"),\n    complete: new Sound(\"./sounds/complete.mp3\"),\n    incorrect: new Sound(\"./sounds/incorrect.mp3\"),\n    playing: new Sound(\"./sounds/playing.mp3\", true)\n};\nasync function loadAllSounds() {\n    await Promise.all(Object.values(exports.sounds).map(sound => sound.load()));\n}\n\n\n//# sourceURL=webpack://stickies/./src/audio.ts?");

/***/ }),

/***/ "./src/config.ts":
/*!***********************!*\
  !*** ./src/config.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.overrides = void 0;\nconst createToken_1 = __webpack_require__(/*! ./utils/createToken */ \"./src/utils/createToken.ts\");\nexports.overrides = {\n    0: {\n        id: 0,\n        rows: 3,\n        cols: 3,\n        tokens: [\n            (0, createToken_1.createToken)({\n                content: \"hello\",\n            })\n        ]\n    }\n};\n\n\n//# sourceURL=webpack://stickies/./src/config.ts?");

/***/ }),

/***/ "./src/game/actions.ts":
/*!*****************************!*\
  !*** ./src/game/actions.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GameActionType = void 0;\nvar GameActionType;\n(function (GameActionType) {\n    GameActionType[\"SET_READY\"] = \"SET_READY\";\n    GameActionType[\"START_PLAYING\"] = \"START_PLAYING\";\n    GameActionType[\"PROCESS_INPUT\"] = \"PROCESS_INPUT\";\n    GameActionType[\"SHOW_RESULTS\"] = \"SHOW_RESULTS\";\n})(GameActionType || (exports.GameActionType = GameActionType = {}));\n\n\n//# sourceURL=webpack://stickies/./src/game/actions.ts?");

/***/ }),

/***/ "./src/game/index.ts":
/*!***************************!*\
  !*** ./src/game/index.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Game = void 0;\nconst createGameState_1 = __webpack_require__(/*! ../utils/createGameState */ \"./src/utils/createGameState.ts\");\nconst reducer_1 = __webpack_require__(/*! ./reducer */ \"./src/game/reducer.ts\");\nclass Game {\n    state;\n    constructor(config) {\n        this.state = (0, createGameState_1.createGameState)(config);\n    }\n    dispatch(action) {\n        this.state = (0, reducer_1.reduceGameState)(this.state, action);\n    }\n}\nexports.Game = Game;\n\n\n//# sourceURL=webpack://stickies/./src/game/index.ts?");

/***/ }),

/***/ "./src/game/reducer.ts":
/*!*****************************!*\
  !*** ./src/game/reducer.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.reduceGameState = reduceGameState;\nconst types_1 = __webpack_require__(/*! ../types */ \"./src/types.ts\");\nconst actions_1 = __webpack_require__(/*! ./actions */ \"./src/game/actions.ts\");\nconst UNDEFINED_CHAR = '';\nfunction reduceGameState(state, action) {\n    switch (action.type) {\n        case actions_1.GameActionType.SET_READY:\n            if (state.status !== types_1.GameStatus.LOADING) {\n                return state;\n            }\n            return {\n                ...state,\n                status: types_1.GameStatus.READY,\n            };\n        case actions_1.GameActionType.START_PLAYING:\n            if (state.status !== types_1.GameStatus.READY) {\n                return state;\n            }\n            return {\n                ...state,\n                status: types_1.GameStatus.PLAYING,\n                startTime: Date.now(),\n                tokenIndex: 0,\n                tokenContentIndex: 0,\n                lastInputIncorrect: false,\n                mistakes: 0,\n            };\n        case actions_1.GameActionType.PROCESS_INPUT:\n            if (state.status !== types_1.GameStatus.PLAYING) {\n                return state;\n            }\n            const { content } = state.config.tokens[state.tokenIndex];\n            const { input } = action;\n            // pad input so that it is at least the lengthof token Content\n            const paddedInput = [...input]\n                .concat(Array.from({ length: content.length - input.length }, () => UNDEFINED_CHAR));\n            // find first index where input does not match token Content\n            const nextContentIndex = paddedInput\n                .map((char, index) => char === content[index])\n                .findIndex(correct => !correct);\n            if (nextContentIndex === -1) {\n                // move to next token\n                const nextTokenIndex = state.tokenIndex + 1;\n                if (nextTokenIndex === state.config.tokens.length) {\n                    return {\n                        ...state,\n                        status: types_1.GameStatus.RESULTS,\n                        endTime: Date.now()\n                    };\n                }\n                return {\n                    ...state,\n                    tokenIndex: nextTokenIndex,\n                    tokenContentIndex: 0,\n                    lastInputIncorrect: false,\n                };\n            }\n            const mistakeWasMade = paddedInput[nextContentIndex] !== UNDEFINED_CHAR;\n            return {\n                ...state,\n                tokenContentIndex: nextContentIndex,\n                lastInputIncorrect: mistakeWasMade,\n                mistakes: state.mistakes + (mistakeWasMade ? 1 : 0),\n            };\n        case actions_1.GameActionType.SHOW_RESULTS:\n            if (state.status !== types_1.GameStatus.PLAYING) {\n                return state;\n            }\n            return {\n                ...state,\n                status: types_1.GameStatus.RESULTS,\n                endTime: Date.now(),\n            };\n        default:\n            return state;\n    }\n}\n\n\n//# sourceURL=webpack://stickies/./src/game/reducer.ts?");

/***/ }),

/***/ "./src/gameGrid/index.ts":
/*!*******************************!*\
  !*** ./src/gameGrid/index.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GameGrid = void 0;\nconst audio_1 = __webpack_require__(/*! ../audio */ \"./src/audio.ts\");\nconst actions_1 = __webpack_require__(/*! ../game/actions */ \"./src/game/actions.ts\");\nconst gameGridLayout_1 = __webpack_require__(/*! ../gameGridLayout */ \"./src/gameGridLayout/index.ts\");\nconst types_1 = __webpack_require__(/*! ../types */ \"./src/types.ts\");\nconst copyToClipboard_1 = __webpack_require__(/*! ../utils/copyToClipboard */ \"./src/utils/copyToClipboard.ts\");\nconst getGameResults_1 = __webpack_require__(/*! ../utils/getGameResults */ \"./src/utils/getGameResults.ts\");\nconst getGameSummary_1 = __webpack_require__(/*! ../utils/getGameSummary */ \"./src/utils/getGameSummary.ts\");\nconst getTextContentFromChar_1 = __webpack_require__(/*! ../utils/getTextContentFromChar */ \"./src/utils/getTextContentFromChar.ts\");\nconst gameStatusToClassNameMap = {\n    [types_1.GameStatus.LOADING]: 'game-loading',\n    [types_1.GameStatus.READY]: 'game-ready',\n    [types_1.GameStatus.PLAYING]: 'game-playing',\n    [types_1.GameStatus.RESULTS]: 'game-results',\n};\n// should rly be gameDOM or something\nclass GameGrid {\n    // this should be cleaned up, it's a disaster\n    // same issue i encountered with the game originally that the\n    // reducer was meant to fix\n    game;\n    layout;\n    gameElements;\n    tokenElements;\n    charElementMatrix;\n    countingDown;\n    showingInstructions;\n    lastInputValue;\n    resultsInterval;\n    constructor(game, gameElements) {\n        this.game = game;\n        this.layout = new gameGridLayout_1.GameGridLayout(game);\n        this.gameElements = gameElements;\n        this.tokenElements = [];\n        this.charElementMatrix = [];\n        this.countingDown = false;\n        this.showingInstructions = false;\n        this.lastInputValue = \"\";\n        const { state: { config: { rows, cols } } } = game;\n        // set up grid\n        gameElements.gridElement.style.gridTemplate = `repeat(${rows}, 1fr) / repeat(${cols}, 1fr)`;\n        this.createTokenAndCharElements();\n        this.createEventListeners();\n        game.dispatch({ type: actions_1.GameActionType.SET_READY });\n        this.update();\n    }\n    placeCellAtCoordinates(charElement, { x, y }) {\n        charElement.style.gridArea = `${y + 1} / ${x + 1} / span 1 / span 1`;\n    }\n    createTokenAndCharElements() {\n        const { game: { state: { config: { tokens } } }, gameElements: { gridElement } } = this;\n        for (const token of tokens) {\n            const { layout, content } = token;\n            const matrixRow = [];\n            const tokenElement = document.createElement('div');\n            tokenElement.classList.add('token');\n            for (let i = 0; i < content.length; i++) {\n                const char = content[i];\n                const charElement = document.createElement('span');\n                charElement.classList.add(\"char\");\n                charElement.textContent = (0, getTextContentFromChar_1.getTextContentFromChar)(char);\n                tokenElement.appendChild(charElement);\n                matrixRow.push(charElement);\n            }\n            this.layout.placeTokenCellsByLayoutType(token, (cellIndex, coordinates) => {\n                const charElement = matrixRow[cellIndex];\n                this.placeCellAtCoordinates(charElement, coordinates);\n            });\n            gridElement.appendChild(tokenElement);\n            this.tokenElements.push(tokenElement);\n            this.charElementMatrix.push(matrixRow);\n        }\n    }\n    async countDown() {\n        this.countingDown = true;\n        const { gameElements: { descriptionElement, gameElement } } = this;\n        const wait = (ms) => new Promise(resolve => setTimeout(resolve, ms));\n        gameElement.classList.add(\"counting-down-3\");\n        descriptionElement.textContent = \"3\";\n        audio_1.sounds.countdown.play();\n        await wait(1000);\n        gameElement.classList.remove(\"counting-down-3\");\n        gameElement.classList.add(\"counting-down-2\");\n        descriptionElement.textContent = \"2\";\n        audio_1.sounds.countdown.play();\n        await wait(1000);\n        gameElement.classList.remove(\"counting-down-1\");\n        gameElement.classList.add(\"counting-down-1\");\n        descriptionElement.textContent = \"1\";\n        audio_1.sounds.countdown.play();\n        await wait(1000);\n        descriptionElement.textContent = \"\";\n        this.countingDown = false;\n    }\n    createEventListeners() {\n        const { game, gameElements: { inputElement, shareElement, instructionsButtonElement, hideInstructionsButtonElement } } = this;\n        window.addEventListener('keydown', () => {\n            if (this.showingInstructions) {\n                return;\n            }\n            inputElement.focus();\n        });\n        inputElement.addEventListener('focus', async () => {\n            this.updateBodyClassNames();\n            if (game.state.status !== types_1.GameStatus.READY || this.countingDown || this.showingInstructions) {\n                return;\n            }\n            instructionsButtonElement.innerHTML = \"good luck!\";\n            instructionsButtonElement.classList.add(\"hidden\");\n            await this.countDown();\n            game.dispatch({ type: actions_1.GameActionType.START_PLAYING });\n            audio_1.sounds.start.play();\n            audio_1.sounds.playing.play(0.75);\n            inputElement.focus();\n            this.update();\n        });\n        inputElement.addEventListener('blur', () => {\n            this.update();\n        });\n        inputElement.addEventListener('input', () => {\n            if (game.state.status !== types_1.GameStatus.PLAYING) {\n                return;\n            }\n            if (inputElement.value.length < this.lastInputValue.length) {\n                inputElement.value = this.lastInputValue;\n            }\n            audio_1.sounds.click.play();\n            game.dispatch({ type: actions_1.GameActionType.PROCESS_INPUT, input: inputElement.value });\n            if (game.state.lastInputIncorrect) {\n                audio_1.sounds.incorrect.play();\n            }\n            this.update();\n            this.lastInputValue = inputElement.value;\n        });\n        shareElement.addEventListener('click', () => {\n            (0, copyToClipboard_1.copyToClipboard)((0, getGameSummary_1.getGameSummary)(game.state));\n            shareElement.textContent = \"copied to clipboard\";\n            setTimeout(() => {\n                shareElement.textContent = \"share results\";\n            }, 1500);\n        });\n        instructionsButtonElement.addEventListener('click', () => {\n            audio_1.sounds.click.play();\n            this.showingInstructions = true;\n            document.body.classList.add(\"showing-instructions\");\n        });\n        hideInstructionsButtonElement.addEventListener('click', () => {\n            audio_1.sounds.click.play();\n            this.showingInstructions = false;\n            document.body.classList.remove(\"showing-instructions\");\n        });\n    }\n    updateInputElement() {\n        const { game: { state }, gameElements: { inputElement } } = this;\n        if (state.status === types_1.GameStatus.PLAYING) {\n            // trim errors\n            inputElement.value = inputElement.value.slice(0, state.tokenContentIndex);\n        }\n        else if (state.status === types_1.GameStatus.RESULTS) {\n            inputElement.setAttribute(\"disabled\", \"\");\n        }\n    }\n    updateCursorPosition() {\n        const { game: { state }, gameElements: { cursorElement }, charElementMatrix } = this;\n        if (state.status !== types_1.GameStatus.PLAYING) {\n            return;\n        }\n        const { tokenIndex, tokenContentIndex } = state;\n        const charElement = charElementMatrix[tokenIndex][tokenContentIndex];\n        // update cursor position\n        const { top, left, width, height } = charElement.getBoundingClientRect();\n        cursorElement.style.top = `${top + height / 2}px`;\n        cursorElement.style.left = `${left + width / 2}px`;\n    }\n    updateBodyClassNames() {\n        const { game: { state }, gameElements: { inputElement } } = this;\n        for (const className of Object.values(gameStatusToClassNameMap)) {\n            document.body.classList.remove(className);\n        }\n        const newClassName = gameStatusToClassNameMap[state.status];\n        if (newClassName) {\n            document.body.classList.add(newClassName);\n        }\n        if (document.activeElement === inputElement) {\n            document.body.classList.add(\"keyboard-open\");\n        }\n        else {\n            document.body.classList.remove(\"keyboard-open\");\n        }\n    }\n    updateGameElementsClassNames() {\n        this.updateBodyClassNames();\n        const { game: { state }, gameElements: { cursorElement, gameElement }, charElementMatrix } = this;\n        if (state.status !== types_1.GameStatus.PLAYING) {\n            return;\n        }\n        const { tokenIndex, tokenContentIndex, lastInputIncorrect } = state;\n        const charElement = charElementMatrix[tokenIndex][tokenContentIndex];\n        const { config: { tokens } } = state;\n        const { errorsShown } = tokens[tokenIndex];\n        for (let i = 0; i <= tokenIndex; i++) {\n            const { highlightedWhenCorrect } = tokens[i];\n            if (!highlightedWhenCorrect) {\n                continue;\n            }\n            if (i < tokenIndex) {\n                for (let j = 0; j < charElementMatrix[i].length; j++) {\n                    charElementMatrix[i][j].classList.add(\"highlighted\");\n                    charElementMatrix[i][j].classList.remove(\"incorrect\");\n                }\n            }\n            else if (i === tokenIndex) {\n                for (let j = 0; j < tokenContentIndex; j++) {\n                    charElementMatrix[i][j].classList.add(\"highlighted\");\n                    charElementMatrix[i][j].classList.remove(\"incorrect\");\n                }\n            }\n        }\n        if (errorsShown) {\n            if (lastInputIncorrect) {\n                charElement.classList.add(\"incorrect\");\n                cursorElement.classList.add(\"incorrect\");\n                gameElement.classList.add(\"shake\");\n            }\n            else {\n                charElement.classList.remove(\"incorrect\");\n                cursorElement.classList.remove(\"incorrect\");\n                gameElement.classList.remove(\"shake\");\n            }\n        }\n    }\n    updateResultsElement() {\n        const { game: { state }, gameElements: { speedElement, mistakesElement } } = this;\n        const updateResults = () => {\n            const { speed, mistakes } = (0, getGameResults_1.getGameResults)(this.game.state);\n            speedElement.textContent = speed;\n            mistakesElement.textContent = mistakes;\n        };\n        if (state.status === types_1.GameStatus.PLAYING && !this.resultsInterval) {\n            this.resultsInterval = setInterval(updateResults, 50);\n        }\n        if (state.status === types_1.GameStatus.RESULTS) {\n            for (const sound of Object.values(audio_1.sounds)) {\n                sound.stop();\n            }\n            audio_1.sounds.complete.play();\n            if (this.resultsInterval) {\n                clearInterval(this.resultsInterval);\n            }\n            updateResults();\n        }\n    }\n    update() {\n        this.updateInputElement();\n        this.updateCursorPosition();\n        this.updateGameElementsClassNames();\n        this.updateResultsElement();\n    }\n}\nexports.GameGrid = GameGrid;\n\n\n//# sourceURL=webpack://stickies/./src/gameGrid/index.ts?");

/***/ }),

/***/ "./src/gameGridLayout/index.ts":
/*!*************************************!*\
  !*** ./src/gameGridLayout/index.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GameGridLayout = void 0;\nconst types_1 = __webpack_require__(/*! ../types */ \"./src/types.ts\");\nclass GameGridLayout {\n    layoutMatrix;\n    config;\n    availableCells;\n    constructor(game) {\n        const { state: { config } } = game;\n        const { rows, cols } = config;\n        this.layoutMatrix = Array.from({ length: rows }, () => Array.from({ length: cols }, () => false));\n        this.config = config;\n        this.availableCells = rows * cols;\n    }\n    *iterateRingClockwiseInward(ringNumber) {\n        const { rows, cols } = this.config;\n        let x = ringNumber;\n        let y = ringNumber;\n        let deltaX = cols - 1 - 2 * ringNumber;\n        let deltaY = rows - 1 - 2 * ringNumber;\n        let increment = 1;\n        for (let j = 0; j < 2; j++) {\n            for (let i = 0; i < deltaX; i++, x += increment) {\n                if (!this.layoutMatrix[y][x]) {\n                    yield { x, y };\n                }\n            }\n            for (let i = 0; i < deltaY; i++, y += increment) {\n                if (!this.layoutMatrix[y][x]) {\n                    yield { x, y };\n                }\n            }\n            if (deltaX === 0 || deltaY === 0) {\n                if (!this.layoutMatrix[y][x]) {\n                    yield { x, y };\n                }\n            }\n            increment *= -1;\n        }\n    }\n    *iterateAvailableCordinatesPerFillType(fillType) {\n        const { rows, cols } = this.config;\n        const maxRingNumber = Math.ceil(Math.min(rows, cols) / 2) - 1;\n        switch (fillType) {\n            case types_1.GameTokenLayoutFillType.LEFT_DOWN:\n                for (let y = 0; y < rows; y++) {\n                    for (let x = 0; x < cols; x++) {\n                        if (!this.layoutMatrix[y][x]) {\n                            yield { x, y };\n                        }\n                    }\n                }\n                return;\n            case types_1.GameTokenLayoutFillType.RIGHT_DOWN:\n                for (let y = 0; y < rows; y++) {\n                    for (let x = cols - 1; x >= 0; x--) {\n                        if (!this.layoutMatrix[y][x]) {\n                            yield { x, y };\n                        }\n                    }\n                }\n                return;\n            case types_1.GameTokenLayoutFillType.LEFT_UP:\n                for (let y = rows - 1; y >= 0; y--) {\n                    for (let x = 0; x < cols; x++) {\n                        if (!this.layoutMatrix[y][x]) {\n                            yield { x, y };\n                        }\n                    }\n                }\n                return;\n            case types_1.GameTokenLayoutFillType.RIGHT_UP:\n                for (let y = rows - 1; y >= 0; y--) {\n                    for (let x = cols - 1; x >= 0; x--) {\n                        if (!this.layoutMatrix[y][x]) {\n                            yield { x, y };\n                        }\n                    }\n                }\n                return;\n            case types_1.GameTokenLayoutFillType.UP_LEFT:\n                for (let x = cols - 1; x >= 0; x--) {\n                    for (let y = rows - 1; y >= 0; y--) {\n                        if (!this.layoutMatrix[y][x]) {\n                            yield { x, y };\n                        }\n                    }\n                }\n                return;\n            case types_1.GameTokenLayoutFillType.UP_RIGHT:\n                for (let x = 0; x < cols; x++) {\n                    for (let y = rows - 1; y >= 0; y--) {\n                        if (!this.layoutMatrix[y][x]) {\n                            yield { x, y };\n                        }\n                    }\n                }\n                return;\n            case types_1.GameTokenLayoutFillType.DOWN_LEFT:\n                for (let x = cols - 1; x >= 0; x--) {\n                    for (let y = 0; y < rows; y++) {\n                        if (!this.layoutMatrix[y][x]) {\n                            yield { x, y };\n                        }\n                    }\n                }\n                return;\n            case types_1.GameTokenLayoutFillType.DOWN_RIGHT:\n                for (let x = 0; x < cols; x++) {\n                    for (let y = 0; y < rows; y++) {\n                        if (!this.layoutMatrix[y][x]) {\n                            yield { x, y };\n                        }\n                    }\n                }\n                return;\n            case types_1.GameTokenLayoutFillType.SPIRAL_CLOCKWISE_INWARDS:\n                for (let ringNumber = 0; ringNumber <= maxRingNumber; ringNumber++) {\n                    for (const coordinates of this.iterateRingClockwiseInward(ringNumber)) {\n                        yield coordinates;\n                    }\n                }\n                return;\n            case types_1.GameTokenLayoutFillType.RANDOM:\n                do {\n                    const x = Math.floor(Math.random() * cols);\n                    const y = Math.floor(Math.random() * rows);\n                    if (!this.layoutMatrix[y][x]) {\n                        yield { x, y };\n                    }\n                } while (this.availableCells > 0);\n                return;\n            case types_1.GameTokenLayoutFillType.SPIRAL_CLOCKWISE_OUTWARDS:\n            case types_1.GameTokenLayoutFillType.BFS:\n            case types_1.GameTokenLayoutFillType.DFS:\n            default:\n                // not yet implemented\n                return;\n        }\n    }\n    markCellUnavailable({ x, y }) {\n        if (!this.layoutMatrix[y][x]) {\n            this.availableCells--;\n        }\n        this.layoutMatrix[y][x] = true;\n    }\n    placeTokenCellsByLayoutType(token, cellCallback) {\n        const { rows, cols } = this.config;\n        const { layout, content } = token;\n        let cellIndex = 0;\n        switch (layout.type) {\n            case types_1.GameTokenLayoutType.DIRECTION:\n                const { initialPosition: { x: initialX, y: initialY }, direction: { x: deltaX, y: deltaY } } = layout;\n                while (cellIndex < content.length) {\n                    let x = initialX + deltaX * cellIndex;\n                    let y = initialY + deltaY * cellIndex;\n                    const outOfBounds = !(x >= 0 && x < cols && y >= 0 && y < rows);\n                    const cellOccupied = this.layoutMatrix?.[y]?.[x];\n                    if (outOfBounds || cellOccupied) {\n                        break;\n                    }\n                    const coordinates = { x, y };\n                    this.markCellUnavailable(coordinates);\n                    cellCallback(cellIndex++, coordinates);\n                }\n                break;\n            default:\n                break;\n        }\n        // fill rest of cells\n        for (const coordinates of this.iterateAvailableCordinatesPerFillType(layout.fillType)) {\n            if (cellIndex >= content.length) {\n                break;\n            }\n            this.markCellUnavailable(coordinates);\n            cellCallback(cellIndex++, coordinates);\n        }\n        if (cellIndex < content.length) {\n            throw new Error(\"no more available cells\");\n        }\n    }\n}\nexports.GameGridLayout = GameGridLayout;\n\n\n//# sourceURL=webpack://stickies/./src/gameGridLayout/index.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst game_1 = __webpack_require__(/*! ./game */ \"./src/game/index.ts\");\nconst isGameElements_1 = __webpack_require__(/*! ./utils/isGameElements */ \"./src/utils/isGameElements.ts\");\nconst gameGrid_1 = __webpack_require__(/*! ./gameGrid */ \"./src/gameGrid/index.ts\");\n__webpack_require__(/*! ./index.scss */ \"./src/index.scss\");\nconst createRandomGameConfig_1 = __webpack_require__(/*! ./utils/createRandomGameConfig */ \"./src/utils/createRandomGameConfig.ts\");\nconst config_1 = __webpack_require__(/*! ./config */ \"./src/config.ts\");\nconst audio_1 = __webpack_require__(/*! ./audio */ \"./src/audio.ts\");\nwindow.addEventListener('load', () => {\n    const gameElements = {\n        gridElement: document.querySelector('.grid'),\n        cursorElement: document.querySelector('.cursor'),\n        inputElement: document.querySelector('.input'),\n        descriptionElement: document.querySelector('.description'),\n        resultsElement: document.querySelector('.results'),\n        speedElement: document.querySelector('.speed'),\n        mistakesElement: document.querySelector('.mistakes'),\n        shareElement: document.querySelector('.share'),\n        gameElement: document.querySelector('.game'),\n        instructionsButtonElement: document.querySelector('.instructions-button'),\n        hideInstructionsButtonElement: document.querySelector('.hide-instructions')\n    };\n    if (!(0, isGameElements_1.isGameElements)(gameElements)) {\n        return;\n    }\n    const id = 1; // getGameId();\n    const config = id in config_1.overrides ? config_1.overrides[id] : (0, createRandomGameConfig_1.createRandomGameConfig)();\n    (0, audio_1.loadAllSounds)();\n    new gameGrid_1.GameGrid(new game_1.Game(config), gameElements);\n});\n\n\n//# sourceURL=webpack://stickies/./src/index.ts?");

/***/ }),

/***/ "./src/types.ts":
/*!**********************!*\
  !*** ./src/types.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GameTokenLayoutType = exports.GameTokenLayoutFillType = exports.GameStatus = void 0;\nvar GameStatus;\n(function (GameStatus) {\n    GameStatus[\"LOADING\"] = \"LOADING\";\n    GameStatus[\"READY\"] = \"READY\";\n    GameStatus[\"PLAYING\"] = \"PLAYING\";\n    GameStatus[\"RESULTS\"] = \"RESULTS\";\n})(GameStatus || (exports.GameStatus = GameStatus = {}));\nvar GameTokenLayoutFillType;\n(function (GameTokenLayoutFillType) {\n    GameTokenLayoutFillType[\"LEFT_DOWN\"] = \"LEFT_DOWN\";\n    GameTokenLayoutFillType[\"RIGHT_DOWN\"] = \"RIGHT_DOWN\";\n    GameTokenLayoutFillType[\"LEFT_UP\"] = \"LEFT_UP\";\n    GameTokenLayoutFillType[\"RIGHT_UP\"] = \"RIGHT_UP\";\n    GameTokenLayoutFillType[\"UP_LEFT\"] = \"UP_LEFT\";\n    GameTokenLayoutFillType[\"UP_RIGHT\"] = \"UP_RIGHT\";\n    GameTokenLayoutFillType[\"DOWN_LEFT\"] = \"DOWN_LEFT\";\n    GameTokenLayoutFillType[\"DOWN_RIGHT\"] = \"DOWN_RIGHT\";\n    GameTokenLayoutFillType[\"DFS\"] = \"DFS\";\n    GameTokenLayoutFillType[\"BFS\"] = \"BFS\";\n    GameTokenLayoutFillType[\"SPIRAL_CLOCKWISE_INWARDS\"] = \"SPIRAL_CLOCKWISE_INWARDS\";\n    GameTokenLayoutFillType[\"SPIRAL_CLOCKWISE_OUTWARDS\"] = \"SPIRAL_CLOCKWISE_OUTWARDS\";\n    // SPIRAL_COUNTERCLOCKWISE_INWARDS = \"SPIRAL_COUNTERCLOCKWISE_INWARDS\",\n    // SPIRAL_COUNTERCLOCKWISE_OUTWARDS = \"SPIRAL_COUNTERCLOCKWISE_OUTWARDS\",\n    GameTokenLayoutFillType[\"RANDOM\"] = \"RANDOM\";\n})(GameTokenLayoutFillType || (exports.GameTokenLayoutFillType = GameTokenLayoutFillType = {}));\nvar GameTokenLayoutType;\n(function (GameTokenLayoutType) {\n    GameTokenLayoutType[\"NONE\"] = \"NONE\";\n    GameTokenLayoutType[\"DIRECTION\"] = \"DIRECTION\";\n})(GameTokenLayoutType || (exports.GameTokenLayoutType = GameTokenLayoutType = {}));\n\n\n//# sourceURL=webpack://stickies/./src/types.ts?");

/***/ }),

/***/ "./src/utils/copyToClipboard.ts":
/*!**************************************!*\
  !*** ./src/utils/copyToClipboard.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.copyToClipboard = copyToClipboard;\nfunction copyToClipboard(text) {\n    const el = document.createElement(\"textarea\");\n    el.value = text;\n    document.body.appendChild(el);\n    el.select();\n    document.execCommand(\"copy\");\n    document.body.removeChild(el);\n}\n\n\n//# sourceURL=webpack://stickies/./src/utils/copyToClipboard.ts?");

/***/ }),

/***/ "./src/utils/createGameState.ts":
/*!**************************************!*\
  !*** ./src/utils/createGameState.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createGameState = createGameState;\nconst types_1 = __webpack_require__(/*! ../types */ \"./src/types.ts\");\nfunction createGameState(config) {\n    return {\n        status: types_1.GameStatus.LOADING,\n        config,\n    };\n}\n\n\n//# sourceURL=webpack://stickies/./src/utils/createGameState.ts?");

/***/ }),

/***/ "./src/utils/createRandomGameConfig.ts":
/*!*********************************************!*\
  !*** ./src/utils/createRandomGameConfig.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createRandomGameConfig = createRandomGameConfig;\nconst types_1 = __webpack_require__(/*! ../types */ \"./src/types.ts\");\nconst createToken_1 = __webpack_require__(/*! ./createToken */ \"./src/utils/createToken.ts\");\n// if difficulty is hard, never show cases\nconst sentences = [\n    [\"Quick\", \"Brown\", \"Fox\"],\n    [\"The\", \"Eiffel\", \"Tower\"],\n    [\"Stonehenge\"],\n    [\"I\", \"Need\", \"More\", \"Friends\"],\n    [\"I\", \"Have\", \"Too\", \"Much\", \"Time\"],\n    [\"Stop\", \"Procrastinating\"],\n    [\"Hello\", \"World\"],\n    [\"Not\", \"My\", \"Cup\", \"Of\", \"Tea\"],\n    [\"Raining\", \"Cats\", \"And\", \"Dogs\"],\n    [\"A\", \"Piece\", \"Of\", \"Cake\"],\n    [\"A\", \"Dime\", \"A\", \"Dozen\"],\n    [\"Back\", \"To\", \"The\", \"Drawing\", \"Board\"],\n    [\"Barking\", \"Up\", \"The\", \"Wrong\", \"Tree\"],\n    [\"Beat\", \"Around\", \"The\", \"Bush\"],\n    [\"Best\", \"Thing\", \"Since\", \"Sliced\", \"Bread\"],\n    [\"Bite\", \"Off\", \"More\", \"Than\", \"You\", \"Can\", \"Chew\"],\n    [\"Burn\", \"The\", \"Midnight\", \"Oil\"],\n    [\"Burst\", \"Your\", \"Bubble\"],\n    [\"Can't\", \"Judge\", \"A\", \"Book\", \"By\", \"Its\", \"Cover\"],\n    [\"When\", \"Pigs\", \"Fly\"],\n    [\"Wild\", \"Goose\", \"Chase\"],\n    [\"When\", \"In\", \"Rome\"],\n    [\"When\", \"It\", \"Rains,\", \"It\", \"Pours\"],\n    [\"When\", \"Life\", \"Gives\", \"You\", \"Lemons,\", \"Make\", \"Lemonade\"],\n    [\"I\", \"Play\", \"This\", \"Game\", \"Too\", \"Much\"],\n    [\"I\", \"Play\", \"This\", \"Game\", \"Too\", \"Little\"],\n    [\"Loser\", \"Loser\", \"Loser\", \"Loser\", \"Loser\"],\n    [\"Sorry?For?Being?So?Annoying\"],\n    [\"~!@#$%^&*()_+\"],\n    [\"a a a a a a a a a a a a a a a a a\"],\n    [\"Go\", \"To\", \"https://smelly.zone\"],\n    [(new Date()).toUTCString()]\n];\nconst randomElementFrom = (array) => array[Math.floor(Math.random() * array.length)];\nconst bidirectionalLayoutTypes = [\n    types_1.GameTokenLayoutFillType.LEFT_UP,\n    types_1.GameTokenLayoutFillType.LEFT_DOWN,\n    types_1.GameTokenLayoutFillType.RIGHT_UP,\n    types_1.GameTokenLayoutFillType.RIGHT_DOWN,\n    types_1.GameTokenLayoutFillType.UP_LEFT,\n    types_1.GameTokenLayoutFillType.UP_RIGHT,\n    types_1.GameTokenLayoutFillType.DOWN_LEFT,\n    types_1.GameTokenLayoutFillType.DOWN_RIGHT,\n];\n// can we generate this given a seed? like todays date in PST. so everyone gets the same thing\nfunction createRandomGameConfig() {\n    const sentence = randomElementFrom(sentences);\n    const size = Math.ceil(Math.sqrt(sentence.join(\"\").length));\n    const config = {\n        id: 0,\n        rows: size,\n        cols: size,\n        tokens: []\n    };\n    const directionLayouts = [\n        {\n            type: types_1.GameTokenLayoutType.DIRECTION,\n            fillType: randomElementFrom(bidirectionalLayoutTypes),\n            initialPosition: { x: 0, y: size - 1 },\n            direction: { x: 1, y: -1 },\n        },\n        {\n            type: types_1.GameTokenLayoutType.DIRECTION,\n            fillType: randomElementFrom(bidirectionalLayoutTypes),\n            initialPosition: { x: size - 1, y: size - 1 },\n            direction: { x: -1, y: -1 },\n        },\n        {\n            type: types_1.GameTokenLayoutType.DIRECTION,\n            fillType: randomElementFrom(bidirectionalLayoutTypes),\n            initialPosition: { x: size - 1, y: 0 },\n            direction: { x: -1, y: 1 },\n        },\n        {\n            type: types_1.GameTokenLayoutType.DIRECTION,\n            fillType: randomElementFrom(bidirectionalLayoutTypes),\n            initialPosition: { x: 0, y: 0 },\n            direction: { x: 1, y: 1 },\n        },\n    ];\n    let wordsToUseDirectionLayout = 0;\n    let wordsToUseSpiralLayout = 0;\n    sentence.forEach((word, index) => {\n        let layout = {\n            type: types_1.GameTokenLayoutType.NONE,\n            fillType: randomElementFrom(bidirectionalLayoutTypes)\n        };\n        if (Math.random() < 0.2) {\n            wordsToUseDirectionLayout++;\n        }\n        if (Math.random() < 0.2) {\n            wordsToUseSpiralLayout++;\n        }\n        if (wordsToUseDirectionLayout > 0) {\n            layout = directionLayouts.pop() || layout;\n            wordsToUseDirectionLayout--;\n        }\n        if (wordsToUseSpiralLayout > 0) {\n            layout.fillType = types_1.GameTokenLayoutFillType.SPIRAL_CLOCKWISE_INWARDS;\n        }\n        config.tokens.push((0, createToken_1.createToken)({\n            content: word,\n            layout\n        }));\n    });\n    return config;\n}\n\n\n//# sourceURL=webpack://stickies/./src/utils/createRandomGameConfig.ts?");

/***/ }),

/***/ "./src/utils/createToken.ts":
/*!**********************************!*\
  !*** ./src/utils/createToken.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createToken = createToken;\nconst types_1 = __webpack_require__(/*! ../types */ \"./src/types.ts\");\nfunction createToken(partialToken) {\n    return {\n        content: '',\n        layout: {\n            type: types_1.GameTokenLayoutType.NONE,\n            fillType: types_1.GameTokenLayoutFillType.LEFT_DOWN\n        },\n        hiddenUntilCorrect: false,\n        highlightedWhenCorrect: true,\n        errorsShown: true,\n        ...partialToken,\n    };\n}\n\n\n//# sourceURL=webpack://stickies/./src/utils/createToken.ts?");

/***/ }),

/***/ "./src/utils/getGameResults.ts":
/*!*************************************!*\
  !*** ./src/utils/getGameResults.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getGameResults = getGameResults;\nconst types_1 = __webpack_require__(/*! ../types */ \"./src/types.ts\");\nfunction getGameResults(state) {\n    const { status } = state;\n    const endTime = status === types_1.GameStatus.RESULTS ? state.endTime : Date.now();\n    const startTime = (status === types_1.GameStatus.RESULTS || status === types_1.GameStatus.PLAYING) ? state.startTime : endTime;\n    const speed = (endTime - startTime) / 1000;\n    const mistakes = (status === types_1.GameStatus.RESULTS || status === types_1.GameStatus.PLAYING) ? state.mistakes : 0;\n    return {\n        speed: `${speed.toFixed(2)}s`,\n        mistakes: `${mistakes} errors`\n    };\n}\n\n\n//# sourceURL=webpack://stickies/./src/utils/getGameResults.ts?");

/***/ }),

/***/ "./src/utils/getGameSummary.ts":
/*!*************************************!*\
  !*** ./src/utils/getGameSummary.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getGameSummary = getGameSummary;\nconst getGameResults_1 = __webpack_require__(/*! ./getGameResults */ \"./src/utils/getGameResults.ts\");\nfunction getGameSummary(state) {\n    const { config: { id } } = state;\n    const { speed, mistakes } = (0, getGameResults_1.getGameResults)(state);\n    const summaryLines = [\n        `stickies! #${id}`,\n        `completed in ${speed} with ${mistakes}`,\n        `try it at https://smelly.zone/stickies`,\n    ];\n    return summaryLines.join(\"\\n\");\n}\n\n\n//# sourceURL=webpack://stickies/./src/utils/getGameSummary.ts?");

/***/ }),

/***/ "./src/utils/getTextContentFromChar.ts":
/*!*********************************************!*\
  !*** ./src/utils/getTextContentFromChar.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getTextContentFromChar = getTextContentFromChar;\nfunction getTextContentFromChar(char) {\n    return char;\n}\n\n\n//# sourceURL=webpack://stickies/./src/utils/getTextContentFromChar.ts?");

/***/ }),

/***/ "./src/utils/isGameElements.ts":
/*!*************************************!*\
  !*** ./src/utils/isGameElements.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isGameElements = isGameElements;\nfunction isGameElements(value) {\n    for (const [key, element] of Object.entries(value)) {\n        if (key === 'inputElement' && !(element instanceof HTMLInputElement)) {\n            return false;\n        }\n        if (!(element instanceof HTMLElement)) {\n            return false;\n        }\n    }\n    return true;\n}\n\n\n//# sourceURL=webpack://stickies/./src/utils/isGameElements.ts?");

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ var __webpack_exports__ = (__webpack_exec__("./src/index.ts"));
/******/ }
]);